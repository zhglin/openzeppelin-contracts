// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.4.0) (account/utils/EIP7702Utils.sol)

pragma solidity ^0.8.20;

/**
 * @dev Library with common EIP-7702 utility functions.
 *
 * See https://eips.ethereum.org/EIPS/eip-7702[ERC-7702].
 */

/*
    由于 EIP-7702 仍处于提案阶段，并且需要硬分叉才能实现，所以：
        * 目前在以太坊主网上无法直接使用 EIP-7702 定义的特殊交易类型。
        * 钱包、DApp 和其他基础设施也尚未原生支持 EIP-7702 的账户行为。
        * 它仍然是一个未来可能实现的功能，旨在解决账户抽象的挑战。
            OpenZeppelin 提供 EIP7702Utils库是为了提前布局，方便开发者在提案最终确定并实现后进行集成。
*/
library EIP7702Utils {
    bytes3 internal constant EIP7702_PREFIX = 0xef0100;

    /**
     * @dev 如果 `account` 具有 EIP-7702 委托设置，则返回委托者的地址，否则返回 address(0)。
     */
    function fetchDelegate(address account) internal view returns (address) {
        // 读取账户的代码
        bytes23 delegation = bytes23(account.code);
        // 检查代码的前3个字节是否是 EIP7702_PREFIX
        // 如果是，则从代码中提取出委托者地址并返回
        // 否则，返回 address(0)
        return bytes3(delegation) == EIP7702_PREFIX ? address(bytes20(delegation << 24)) : address(0);
    }
}

/*
    EIP7702Utils.sol 这个库是 OpenZeppelin 提供的一个辅助工具，专门用于处理 EIP-7702 提案相关的逻辑。
    1. 什么是 EIP-7702？
        EIP-7702 是一个关于账户抽象（Account Abstraction）的以太坊改进提案。
        它的核心思想是允许外部拥有账户（EOA）临时地表现得像智能合约账户一样，从而获得智能合约账户的灵活性，而无需用户将资产迁移到新的智能合约钱包。
    EIP-7702 的工作原理是：
        * 一个 EOA 可以通过一个特殊的交易，将其账户的代码（`account.code`）设置为一个特定的模式。
        * 这个模式由一个前缀 `0xef0100` 加上一个 20字节的“委托者”（delegate）智能合约地址组成。
        * 当一个交易从这样一个 EOA 发出时，EVM（以太坊虚拟机）会识别这个特殊的代码模式。
        * EVM 不会像往常一样使用 EOA 的私钥进行验证，而是会调用这个 EOA 代码中指定的“委托者”智能合约上的验证函数
            （例如isValidSignature），让委托者合约来决定交易是否有效。
    这样，EOA 就可以将它的验证逻辑委托给一个智能合约，从而实现多签、社交恢复、自定义验证等智能合约钱包的功能。

    * `EIP7702_PREFIX`：这是 EIP-7702 提案中定义的特殊前缀，用于标识一个 EOA 已经启用了委托功能。
    * `fetchDelegate(address account)`：
        * 这个函数接收一个 account 地址。
        * 它会读取这个 account 地址上的合约代码（如果它是 EOA，并且启用了 EIP-7702，那么它的代码就是那个特殊的模式）。
        * 它检查代码的前3个字节是否与 EIP7702_PREFIX 匹配。
        * 如果匹配，它就从代码中解析出 20 字节的委托者智能合约地址并返回。
        * 如果不匹配，或者该地址没有代码，它就返回 address(0)。

    3. 为什么“没地方用”？
    您观察到它在当前查看的文件中没有被直接使用，这是很正常的，原因如下：
    * 它是“工具库”：EIP7702Utils 是一个工具库（utility library），它的设计目的不是让它自己被直接调用，
        而是供其他合约导入并使用，以便与其他EIP-7702 账户进行交互。
    * 使用场景：
        * 例如，一个需要验证签名的合约（如一个 DApp 的链上部分），在收到一个来自 EOA 的签名时，它可能会先调用
            EIP7702Utils.fetchDelegate(signerAddress) 来检查这个 EOA 是否启用了 EIP-7702 委托。
        * 如果 fetchDelegate 返回了一个非零地址，那么这个合约就知道它应该调用这个返回地址上的 isValidSignature 函数来验证签名，
            而不是尝试 ecrecover。
    * EIP-7702 仍在发展中：EIP-7702 是一个相对较新的提案，可能还没有被广泛集成到所有的合约中。
        OpenZeppelin提供了这个库，是为了方便未来其他合约支持 EIP-7702。


    1. EOA 的“代码”通常是什么？
        首先，我们需要理解外部拥有账户（EOA）的本质。EOA 是由私钥控制的账户，它们在区块链上通常没有关联的代码。
            如果你查询一个普通 EOA 的account.code，你会得到一个空值（0x）。这意味着 EOA 无法执行任何复杂的链上逻辑，
            只能发送和接收以太币或代币。
    2. EIP-7702 提出的“特殊交易”
        EIP-7702 提案的核心创新之一，就是引入了一种新的交易类型（或对现有交易语义的修改），允许 EOA 执行一个在以太坊协议层面被特殊处理的交易。
        这个“特殊交易”的目的不是部署一个新的智能合约，而是修改 EOA 自身的 `account.code` 字段。
        具体来说，这个交易会包含：
            * 交易类型标识符：表明这是一个 EIP-7702 交易。
            * `code` 字段：这个字段不再是空的，而是包含一个特定的字节码模式。
            * 签名：由 EOA 的私钥对整个交易进行签名，以授权这个代码修改。
    3. account.code 被设置为的“特定模式”
        根据 EIP-7702 的定义，这个特殊的字节码模式是：
            0xef0100 (3字节的前缀) + [20字节的委托者（delegate）智能合约地址]
                * `0xef0100`：这是一个魔术前缀，EVM 会识别它，表明这个 EOA 已经启用了 EIP-7702 委托功能。
                * `[20字节的委托者智能合约地址]`：这是用户指定的、一个已经部署在链上的智能合约的地址。这个合约将负责处理 EOA 的验证逻辑。
    4. 为什么这个交易是“特殊的”？
        * EOA 获得代码：这是对 EOA 传统定义的根本性改变。EOA 第一次可以在区块链上拥有非空的 account.code。
        * 修改现有账户的代码：在以太坊中，一旦智能合约部署，其代码通常是不可变的。EIP-7702 允许 EOA 的代码被修改，这需要协议层面的支持。
        * 改变验证机制：一旦 EOA 的代码被设置为这种模式，EVM 在处理来自该 EOA 的交易时，将不再使用 EOA 的私钥进行验证。
            相反，它会识别 0xef0100前缀，并将验证任务委托给代码中指定的 20 字节委托者智能合约。
    5. 效果和意义
        通过这种“特殊交易”：
            * EOA 获得了智能合约账户的能力：用户无需将资产转移到新的智能合约钱包地址，就可以让现有的 EOA 拥有多签、社交恢复、自定义验证逻辑等功能。
            * 账户抽象的实现：这是实现账户抽象的一种方式，它将验证逻辑从 EOA 的私钥中解耦出来，转移到可编程的智能合约中。
            * 向后兼容性：由于 EOA 地址保持不变，它与现有的 DApp 和工具具有更好的兼容性。    
*/